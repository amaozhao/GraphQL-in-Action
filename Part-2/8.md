# 实施突变
本章涵盖

- 实现 GraphQL 的变异字段
- 验证用户进行突变和查询操作
- 创建自定义的、用户友好的错误消息
- 使用强大的数据库功能来优化突变

我们在第 7 章中为 AZdev GraphQL API 实现了大部分查询树。现在是时候实现我们计划的突变操作了，从 userCreate 突变开始，使 AZdev 用户能够创建一个帐户并使用其他突变（和查询）需要 经过身份验证的请求。

由于这是我们创建的第一个突变，我们需要做一些基础工作来为所有突变做好准备。 我们基本上需要让模式准备好承载突变。

> 当前代码
>
> 使用 git checkout 8.0 将你的本地存储库重置为代码中的当前进度。 如果你需要存储任何本地更改，请使用 git add 。 && git 存储。 请记住运行 npm install 以安装任何缺少的依赖项。

## 8.1 增变器上下文对象

我们已经抽象了所有数据库读取操作，以使用我们作为全局 GraphQL 上下文的一部分传递给每个解析器的加载器对象来遍历 DataLoader 实例。 是时候考虑 WRITE 操作了。 每个变异操作都将执行 INSERT、UPDATE 或 DELETE SQL 语句或 MongoDB 操作（或它们的组合）。 这些 WRITE 操作不需要经过 DataLoader。 虽然我们可以让突变的 READ 部分通过 DataLoader，但我认为这将是一个过度工程的案例。

提示一个突变可以包含多个字段，导致服务器执行多个数据库写/读操作。 但是，与并行执行的查询字段不同，突变字段按顺序运行，一个接一个。 如果 API 消费者发送两个突变字段，则保证第一个在第二个开始之前完成。 这是为了确保不会发生竞争条件，但它也会使 DataLoader 之类的任务复杂化。

让我们向全局上下文添加另一个负责突变的对象。 我将其命名为突变体。 该对象将承载所有数据库变更操作（对于 PostgreSQL 和 MongoDB）。 事实上，让我们计划将所有数据库操作分组在数据库 API 对象中的一个 mutators 属性下。 向 pgApi 和 mongoApi 添加一个 mutators 属性。

清单 8.1 api/src/db/pg-api.js 中的变化

```js
const pgApiWrapper = async () => {
  // ·-·-·
 
  return {
    // ·-·-·
 
    mutators: {
 
    },
  };
};
```

清单 8.2 api/src/db/mongo-api.js 中的变化

```js
const mongoApiWrapper = async () => {
  // ·-·-·
 
  return {
    // ·-·-·
 
    mutators: {
 
    },
  };
};
```

每个未来的变异操作都将是这些新变异器属性的子属性。

提示你还可以将 DataLoader 使用的所有 pgApi 函数分组在一个 loaders 属性下，但为了简单起见，我将在这里跳过它。 理想情况下，每个加载器或修改器函数都应该有自己的文件并托管自己的数据库语句。 我将把这个重构留给你作为练习。

现在，在 api/src/server.js 中，让我们创建一个新对象来托管所有数据库突变操作（来自两个数据库）并使该对象成为全局上下文的一部分。

清单 8.3 api/src/server.js 中的变化

```js
async function main() {
  // ·-·-·
 
  server.use('/', (req, res) => {
    // ·-·-·
 
    const mutators = {
      ...pgApi.mutators,
      ...mongoApi.mutators,
    };
 
    graphqlHTTP({
      schema,
      context: { loaders, mutators },
      graphiql: true,
    })(req, res);
  });
 
  // ·-·-·
 };
```

现在所有突变解析器都可以访问所有数据库突变操作。

TIP 查询字段的解析器也可以访问这个新的 mutators 对象。 但是，他们永远不应该使用它。 查询字段应该是纯净的并且不会产生副作用。

## 8.2 突变类型

正如我们定义了一个 QueryType 来保存 API 消费者可以开始的所有根查询字段一样，我们需要定义一个 MutationType 来保存 API 消费者可以调用的所有突变字段。 我们在 api/src/schema/index.js 中这样做，反映了我们已经拥有的 QueryType。

清单 8.4 api/src/schema/index.js 中的变化

```js
import QueryType from './queries';
import MutationType from './mutations';
 
export const schema = new GraphQLSchema({
  query: QueryType,
  mutation: MutationType,
});
```

新的 mutations.js 文件将位于 api/src/schema 下，它将使用常规的 GraphQLObjectType 对象。

清单 8.5 新文件：api/src/schema/mutations.js

```js
import { GraphQLObjectType } from 'graphql';
const MutationType = new GraphQLObjectType({
  name: 'Mutation',
  fields: () => ({
    // ·-·-·
  }),
});
 
export default MutationType;
```

## 8.3 用户突变

现在我们有了支持变更操作的框架，让我们来处理前两个变更，它们将允许此 API 的使用者创建帐户 (userCreate)，然后获取身份验证令牌以使用其他变更 (userLogin)。

请记住，对于每个突变，除了主要突变字段之外，我们还需要定义两种类型：输入类型和有效载荷类型。 对于第一个突变，我们还需要定义 UserError 类型，我们计划在用户发送突变错误输入（例如，短密码）时使用它来表示用户友好的错误消息。

### 8.3.1 userCreate 突变

这是我们需要关注 userCreate 突变的 SDL 部分。

清单 8.6 用于 userCreate 及其依赖项的 SDL

```js
input UserInput {
  username: String!
  password: String!
  firstName: String
  lastName: String
}
 
type UserError {
  message: String!
}
 
type UserPayload {
  errors: [UserError!]!
  user: User
  authToken: String!
}
 
type Mutation {
  userCreate(input: UserInput!): UserPayload!
 
  # More mutations
}
```

通用 UserError 类型是 GraphQLObjectType 的一个简单实例。 放在 api/src/schema/types/user-error.js 下。

清单 8.7 新文件：api/src/schema/types/user-error.js

```js
import {
  GraphQLObjectType,
  GraphQLString,
  GraphQLNonNull,
} from 'graphql';
 
const UserError = new GraphQLObjectType({
  name: 'UserError',
  fields: () => ({
    message: {
      type: new GraphQLNonNull(GraphQLString),
    },
  }),
});
 
export default UserError;
```

我们现在可以定义 UserPayload 类型，它使用 UserError 类型。 UserPayload 类型用于两个突变（userCreate 和 userLogin），所以让我们将其放在 api/src/schema/types/payload-user.js 下的自己的文件中。

清单 8.8 新文件：api/src/schema/types/payload-user.js

```js
import {
  GraphQLObjectType,
  GraphQLString,
  GraphQLNonNull,
  GraphQLList,
} from 'graphql';
 
import User from './user';
import UserError from './user-error';
 
const UserPayload = new GraphQLObjectType({
  name: 'UserPayload',
  fields: () => ({
    errors: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(UserError)),
      ),
    },
    user: { type: User },
    authToken: { type: GraphQLString },
  }),
});
 
export default UserPayload;
```

现在我们可以实现突变字段及其 UserInput 类型。 要使用此突变，消费者必须提供用户名地址和密码； 他们可以选择提供名字和姓氏。 通常，你希望消费者的输入至少包括数据库中的所有非空字段：在本例中为用户名和密码。 没有这些我们就无法创建用户记录。

提示 请注意，我将文件命名为 payload-user.js 而不是 user-payload.js。 我这样做是为了将有效载荷类型组合在类型目录中。 在更大的项目中，你可以将不同的 GraphQL 类型组织在不同的目录下，用于类别或 API 功能。

对于 UserInput 类型，我们需要使用 GraphQLInputObjectType 对象。 这是另一个类似于 GraphQLObjectType 的 GraphQL.js 构造函数对象。

清单 8.9 新文件：api/src/schema/types/input-user.js

```js
import {
  GraphQLInputObjectType,
  GraphQLString,
  GraphQLNonNull,
} from 'graphql';
 
const UserInput = new GraphQLInputObjectType({
  name: 'UserInput',
  fields: () => ({
    username: { type: new GraphQLNonNull(GraphQLString) },
    password: { type: new GraphQLNonNull(GraphQLString) },
    firstName: { type: GraphQLString },
    lastName: { type: GraphQLString },
  }),
});
 
export default UserInput;
```

现在我们可以将 UserPayload 和 UserInput 类型导入 api/src/schema/mutations.js 并定义 userCreate 字段对象——就像查询字段一样，它具有类型、参数和解析属性。

清单 8.10 api/src/schema/mutations.js 中的变化

```js
import { GraphQLObjectType, GraphQLNonNull } from 'graphql';
import UserPayload from './types/payload-user';
import UserInput from './types/input-user';
 
const MutationType = new GraphQLObjectType({
  name: 'Mutation',
  fields: () => ({
    userCreate: {
      type: new GraphQLNonNull(UserPayload),
      args: {
        input: { type: new GraphQLNonNull(UserInput) },
      },
      resolve: async (source, { input }, { mutators }) => {
        return mutators.userCreate({ input });               ❶
      },
    },
  }),
});
 
export default MutationType;
```

❶ mutators.userCreate 方法还不存在。

最后，我们需要实现我们在 resolve 函数中使用的 mutators.userCreate。 它需要一个具有输入属性的对象（它本身是一个 UserInput 类型的对象）。

提示 请注意，我将 mutators 函数名称与使用它的字段相匹配。 这只是我的一种风格偏好，可以让方法按主题分组，我认为这是一种在任何地方都可以遵循的有用做法。 但是，在更大的代码库中，你应该考虑为方法添加后缀，以便于查找和替换它们。 例如，你可以执行类似 userCreateLoader 和 userCreateMutator 的操作。

请记住，GraphQL 变更始终是一个 WRITE 操作，然后是一个 READ 操作。 突变的类型是它完成后可以读取的内容。 在这种情况下，它是一个 UserPayload 记录，其中包括从数据库中新创建的用户记录。 新创建的用户记录必须从数据库中读取，因为它需要包含数据库自动填充的值（如序列 ID 和创建时间戳信息）。 这意味着我们需要一个 INSERT 语句后跟一个 SELECT 语句。

那时 PostgreSQL 会让你大吃一惊。 我们实际上可以使用相同的 INSERT 语句告诉 PostgreSQL 返回新创建的记录。 这是一个例子。

清单 8.11 示例：PostgreSQL 的 RETURNING 子句

```sql
INSERT INTO azdev.users (username, password)
  VALUES ('janedoe', 'ChangeMe')
RETURNING id, username, created_at
```

你是否注意到 RETURNING 部分？ 此 INSERT 语句不仅会在表中插入一行，还会从该新行中选择列并在同一数据库操作中返回它们。 这是我最喜欢的 PostgreSQL 特性之一。

有了这个魔法，我们需要做的就是读取输入值并将它们传递给该 INSERT 语句的一个版本，但有一些更多的细节来散列密码和别名列。 如果消费者发送的密码值少于六个字符，我还将包含一个示例，通过阻止突变操作，你可以在有效负载中使用 UserError 结构。

这是我为 mutators.userCreate 函数想出的。

清单 8.12 api/src/db/pg-api.js 中的新修改器方法

```js
// ·-·-·
 
import { randomString } from '../utils';
 
const pgApiWrapper = async () => {
  // ·-·-·
 
  return {
    // ·-·-·
 
    mutators: {
      // ·-·-·
 
      userCreate: async ({ input }) => {
        const payload = { errors: [] };
        if (input.password.length < 6) {
          payload.errors.push({
            message: 'Use a stronger password',
          });
        }
        if (payload.errors.length === 0) {
          const authToken = randomString();                 ❶
          const pgResp = await pgQuery(sqls.userInsert, {   ❷
            $1: input.username.toLowerCase(),
            $2: input.password,
            $3: input.firstName,
            $4: input.lastName,
            $5: authToken,
          });
          if (pgResp.rows[0]) {
            payload.user = pgResp.rows[0];
            payload.authToken = authToken;
          }
        }
        return payload;
      },
    },
  };
};
```

❶ randomString 函数返回一个随机字符串。 它已经在 api/src/utils.js 中实现。
❷ userInsert SQL 语句向 azdev.users 表中插入一行。 它已经在 api/src/db/sqls.js 中实现。

请记住，auth_token 就像一个临时密码。 这就是它的值也被散列的原因，但用户应该使用纯文本版本（随机生成）。

请注意，就像查询字段的解析函数一样，变异的解析函数也可以返回一个承诺，而 GraphQL.js 会为我们做"等待"。 另请注意，"短密码"错误会完全阻止 INSERT 语句（否则，有什么意义？），但有时可能会在 INSERT 语句期间捕获用户错误。 例如，要确保提供的用户名值不是已使用的值，而不是在 INSERT 语句之前发出额外的 SELECT 语句，我们可以简单地让 INSERT 语句失败，因为数据库已经对该列进行了验证。 让我把它留在这里作为你的练习。 此外，围绕 firstName 和 lastName 输入值进行验证。 例如，不允许使用数字。 如果消费者发送的名称为 { firstName: "James", lastName: "007" }，则该操作失败并出现用户错误。

要测试 userCreate 变更，这里有一个你可以在 GraphiQL 中使用的请求。

清单 8.13 测试 userCreate 的变更请求示例

```js
mutation userCreate {
  userCreate(input: {
    username: "janedoe"
    password: "123"        ❶
    firstName: "Jane"
    lastName: "Doe"
  }) {
    errors {
      message
    }
    user {
      id
      name
    }
    authToken
  }
}
```

❶ 首先尝试使用一个短密码以查看 UserError 响应，然后再使用一个有效密码进行尝试。

图 8.1 显示了当你尝试使用短密码时应该得到的响应。

![](../images/ch-8/8-1.png)

图 8.1 用户错误数据响应

提示 存储的 auth_token 值应在特定时间后过期。 一种方法是向 azdev.users 添加另一列来管理每个令牌的时间有效性。

> 当前代码
>
> 使用 git checkout 8.1 将你的本地存储库重置为代码中的当前进度。

### 8.3.2 userLogin 突变

为了向返回的用户提供一种获取新的 auth_token 值的方法，我们需要实现 userLogin 突变。 这是为其实现的 SDL 文本部分。

清单 8.14 userLogin 及其依赖项的 SDL

```js
input AuthInput {
  username: String!
  password: String!
}
 
type Mutation {
  userLogin(input: AuthInput!): UserPayload!
 
  # ·-·-·
}
```

我们已经实现了 UserPayload 类型，所以我们可以在这里重用它，但是我们需要创建 AuthInput 类型。 这很简单，它类似于 UserInput 类型。 将以下内容放入 api/src/schema/types/input-auth.js。

清单 8.15 新文件：api/src/schema/types/input-auth.js

```js
import {
  GraphQLInputObjectType,
  GraphQLString,
  GraphQLNonNull,
} from 'graphql';
 
const AuthInput = new GraphQLInputObjectType({
  name: 'AuthInput',
  fields: () => ({
    username: { type: new GraphQLNonNull(GraphQLString) },
    password: { type: new GraphQLNonNull(GraphQLString) },
  }),
});
 
export default AuthInput;
```

```userLogin mutation``` 字段需要在 MutationType 下定义（在 ```api/src/schema/mutations.js``` 中）。 这也类似于 userCreate 字段，只是它将使用不同的 mutators 函数。

清单 8.16 api/src/schema/mutations.js 中的变化

```js
// ·-·-·
 
import AuthInput from './types/input-auth';
 
const MutationType = new GraphQLObjectType({
  name: 'Mutation',
  fields: () => ({
    // ·-·-·
    userLogin: {
      type: new GraphQLNonNull(UserPayload),
      args: {
        input: { type: new GraphQLNonNull(AuthInput) },
      },
      resolve: async (source, { input }, { mutators }) => {
        return mutators.userLogin({ input });
      },
    },
  }),
});
 
export default MutationType;
```

虽然可以使用单个数据库 UPDATE 语句执行此更改操作，但我将使用两个语句执行此操作：一个用于验证输入的用户名/密码值 (sqls.userFromCredentials)，另一个用于更新数据库中的 auth_token 用户字段 ( ```sqls.userUpdateAuthToken```）。 看看 ```api/src/db/sqls.js``` 中的这两个准备好的语句。

提示 这两个 SQL 语句都使用来自 pgcrypto 扩展 (```az.dev/pgcrypto```) 的 PostgreSQL 的 crypt 函数。

对于这个 ```mutators``` 函数的输入验证，让我们确保用户名/密码值不为空。 这是我为这个功能想出的实现。

清单 8.17 api/src/db/pg-api.js 中的变化

```js
const pgApiWrapper = async () => {
  // ·-·-·
 
  return {
    // ·-·-·
 
    mutators: {
      // ·-·-·
       userLogin: async ({ input }) => {
        const payload = { errors: [] };
        if (!input.username || !input.password) {
          payload.errors.push({
            message: 'Invalid username or password',
          });
        }
        if (payload.errors.length === 0) {
          const pgResp = await pgQuery(sqls.userFromCredentials, {
            $1: input.username.toLowerCase(),
            $2: input.password,
          });
          const user = pgResp.rows[0];
          if (user) {
            const authToken = randomString();
            await pgQuery(sqls.userUpdateAuthToken, {
              $1: user.id,
              $2: authToken,
            });
            payload.user = user;
            payload.authToken = authToken;
          } else {
            payload.errors.push({
              message: 'Invalid username or password'
            });
          }
        }
        return payload;
      },
    },
  };
};
```

我们首先检查 input.username 和 input.password 中的值，如果它们为空，则将用户错误推送到有效负载。 尽管这些输入字段在输入对象中被定义为非空值，但空值仍将通过 GraphQL 验证。 然后，如果用户名和密码有效，我们可以更新 users 表以存储随机生成的新 authToken 值的哈希值，并将其纯文本版本作为有效负载的一部分返回。

> 提示 我们不需要区分密码的无效和用户名的无效。 将两个验证分组为一个更安全。

要测试 userLogin 突变，这里有一个你可以在 GraphiQL 中使用的请求。

清单 8.18 请求测试 userLogin

```js
mutation userLogin {
  userLogin(input: {
    username: "test",       ❶
    password: "123456"
  }) {
    errors {
      message
    }
    user {
      id
      name
    }
    authToken
  }
}
```

❶ "test/123456"凭证有效（来自示例开发数据）。

使用有效密码和无效密码尝试这种突变（图 8.2 和 8.3），并确保两种情况都正常工作。

![](../images/ch-8/8-2.png)


图 8.2 使用无效凭据测试 userLogin 突变

提示保存返回的有效 ```authToken``` 值，因为我们在下一节中需要它。

> 当前代码
>
> 使用 git checkout 8.2 将你的本地存储库重置为代码中的当前进度。

![](../images/ch-8/8-3.png)

图 8.3 使用有效凭据测试 userLogin 突变

## 8.4 验证 API 消费者

现在我们可以使用 API 获取有效的 authToken 值，我们需要弄清楚如何将该令牌包含在未来请求的标头中，以便我们可以将它用于需要有效用户会话的 ```GraphQL``` 操作。

与 ```express-graphql``` 包捆绑在一起的 GraphiQL 编辑器支持标题编辑器（类似于变量编辑器）。 要启用它，请在 ```api/src/server.js``` 中进行以下更改。

清单 8.19 api/src/server.js 中的变化

```js
async function main() {
  // ·-·-·
 
  server.use('/', (req, res) => {
    // ·-·-·
    graphqlHTTP({
      schema,
      context: { loaders, mutators },
      graphiql: { headerEditorEnabled: true },
      // ·-·-·
    })(req, res);
  });
 
  // ·-·-·
}
```

GraphiQL 编辑器现在应该显示 REQUEST HEADERS 编辑器（图 8.4）。

![](../images/ch-8/8-4.png)


图 8.4 GraphiQL 中的请求标头部分

我们可以使用 Authorization 请求标头将 ```authToken``` 值包含在 ```GraphiQL``` 发出的每个请求中。 该请求标头的语法如下所示。

清单 8.20 示例：授权标头的语法

```js
Authorization: <type> <credentials>      ❶
```

❶ 身份验证的主要类型有 Basic、Bearer、Digest、HOBA、Mutual、Client 和 Form Based。 凭据取决于类型。

由于我们使用的是单个字符串值 authToken，因此我们可以使用 Bearer 类型（这是一个基于令牌的系统）。

> 提示 Bearer 类型是 OAuth 开放标准和 JWT 的基础。 我的计划是实现最基本形式的基于令牌的身份验证，并让你在此基础上进行构建。 如果你有兴趣了解有关 API 安全性的更多信息，请查看 Neil Madden（Manning，2019 年）所著的 API Security in Action 一书，网址为 www.manning.com/books/api-security-in-action。

还记得我们在将 null 作为当前 userId 值传递的 pgApi 函数中留下的 TODO 吗？ 一个用于 taskInfo 根查询字段，另一个用于搜索根查询字段。 让我们先解决这些问题。

使用 userLogin 突变以使用"test/123456"凭据获取有效的 authToken 值。 该用户拥有一个私人任务记录，如果他们发送以下 GraphQL 查询，该记录应该会显示。

清单 8.21 搜索私有任务记录

```js
{
  search(term: "babel") {
    content
  }
}
```

要包含 authToken 值，请将其放入请求标头编辑器中：

```js
{
  "Authorization": "Bearer AUTH_TOKEN_VALUE_HERE"     ❶
}
```

❶ 将其替换为你从 userLogin 突变中获得的有效 authToken 值。

这个查询目前没有返回任何数据，我们需要让它工作，因为消费者现在正在向服务器发送一个有效的 authToken 值。

我准备了一个 SQL 语句 (```sqls.userFromAuthToken```) 来使用 authToken 值查找用户记录。 让我们在 ```api/src/db/pg-api.js``` 中创建一个 ```pgApi.userFromAuthToken``` 函数来使用该语句。

清单 8.22 api/src/db/pg-api.js 中的变化

```js
const pgApiWrapper = async () => {
  // ·-·-·
 
  return {
    userFromAuthToken: async (authToken) => {
      if (!authToken) {
        return null;
      }
      const pgResp = await pgQuery(sqls.userFromAuthToken, {
        $1: authToken,
      });
      return pgResp.rows[0];
    },
 
    // ·-·-·
  };
};
```

```pgApi.userFromAuthToken``` 函数比较特殊。 它不会被 DataLoader 实例使用。 它甚至不是 ```GraphQL``` 解析逻辑的一部分。 在与 ```GraphQL``` 通信之前我们需要它。

不要在 ```GraphQL``` 解析逻辑中进行身份验证。 最好在 ```GraphQL``` 服务层之前或之后让不同的层处理它。 我们将在 ```Express``` 请求处理层（我们还准备了加载程序对象）中进行身份验证工作。 然后我们可以将 ```currentUser``` 值传递给搜索逻辑，以将其包含在 sqls.searchResults 语句（旨在接受用户 ID 值）中。

在 ```api/src/server.js``` 中，在 loaders 对象之前添加以下内容。

清单 8.23 api/src/server.js 中的变化

```js
async function main() {
  // ·-·-·
 
  server.use('/', async (req, res) => {      ❶
    const authToken =
      req && req.headers && req.headers.authorization
        ? req.headers.authorization.slice(7) // "Bearer "
        : null;
    const currentUser = await pgApi.userFromAuthToken(authToken);
    if (authToken && !currentUser) {
      return res.status(401).send({
        errors: [{ message: 'Invalid access token' }],
      });
    }
 
    // ·-·-·
  });
 
  // ·-·-·
}
```

❶ 注意新的 async 关键字，这是必需的，因为新代码在 ```userFromAuthToken``` 异步函数上使用了 await 关键字。

当存在授权标头（由 ```Express``` 解析）时，我们将通过 ```pgApi.userFromAuthToken``` 函数验证 authToken 值。

请注意，当存在无效的 authToken（未找到用户记录）时，我让服务器返回 401 错误。 这比静静地失败而不考虑用户登录更可取。应该通知用户他们正在使用无效的 authToken 值（例如，它可能已过期，他们需要注销并重新登录）。 另请注意，我格式化了返回的错误以匹配 ```GraphQL``` 自己的根错误（具有消息属性的错误对象数组）。 这个逻辑仍然作为 ```GraphQL``` 请求的一部分执行，并且它应该符合 ```GraphQL``` 格式化错误的方式。

现在我们将处理 pgApi 方法，我们在其中留下一个 TODO 以包含一个可以使用新的 currentUser 变量的 userId 值。 ```pgApi.tasksInfo``` 和 ```pgApi.searchResults``` 都需要它。 让我们将他们的参数更改为一个对象，以便我们可以包含 currentUser 值。

清单 8.24 api/src/server.js 中的变化

```js
async function main() {
  // ·-·-·
 
  server.use('/', async (req, res) => {
    // ·-·-·
 
    const loaders = {
      users: new DataLoader((userIds) => pgApi.usersInfo(userIds)),
      approachLists: new DataLoader((taskIds) =>
        pgApi.approachLists(taskIds),
      ),
      tasks: new DataLoader((taskIds) =>
        pgApi.tasksInfo({ taskIds, currentUser }),
      ),
      tasksByTypes: new DataLoader((types) =>
        pgApi.tasksByTypes(types),
      ),
      searchResults: new DataLoader((searchTerms) =>
        pgApi.searchResults({ searchTerms, currentUser }),
      ),
      detailLists: new DataLoader((approachIds) =>
        mongoApi.detailLists(approachIds),
      ),
    };
 
    // ·-·-·
  });
 
  // ·-·-·
}
```

然后，更改 pgApi 函数以考虑新的参数设计和 currentUser 值。

清单 8.25 api/src/db/pg-api.js 中的变化

```js
const pgApiWrapper = async () => {
  // ·-·-·
 
  return {
    // ·-·-·
    tasksInfo: async ({ taskIds, currentUser }) => {
      const pgResp = await pgQuery(sqls.tasksFromIds, {
        $1: taskIds,
        $2: currentUser ? currentUser.id : null,
      });
      return taskIds.map((taskId) =>
        pgResp.rows.find((row) => taskId == row.id),
      );
    },
    searchResults: async ({ searchTerms, currentUser }) => {
      const results = searchTerms.map(async (searchTerm) => {
        const pgResp = await pgQuery(sqls.searchResults, {
          $1: searchTerm,
          $2: currentUser ? currentUser.id : null,
        });
        return pgResp.rows;
      });
      return Promise.all(results);
    },
 
    // ·-·-·
  };
};
```

而已。 你现在可以测试"babel"搜索查询，它应该可以工作。 同样使用无效的 authToken 值对其进行测试（图 8.5 和 8.6）。

![](../images/ch-8/8-5.png)

图 8.5 使用 GraphQL 查询发送请求标头

![](../images/ch-8/8-6.png)

图 8.6 测试无效授权请求标头

当你为测试用户使用有效的 authToken 值时，taskInfo 根查询字段也应该适用于任务 5。

> 当前代码
>
> 使用 git checkout 8.3 将你的本地存储库重置为代码中的当前进度。

### 8.4.1 me根查询字段

接下来让我们实现 me 根查询字段。 以下是与该字段相关的SDL部分。

清单 8.26 me 字段的 SDL 文本

```js
type Query {
  // ·-·-·
  me: User
}
 
type User {
  id: ID!
  createdAt: String!
  username: String!
  name: String
  taskList: [Task!]!
}
```

我们实现了 User 类型但没有 taskList 字段。 现在我们正在实现 me 字段，是时候在 User 类型上也支持 taskList 字段，但将其限制为仅在 me 字段范围内可用。

让我们从 me 字段本身开始。 这是我们可以用来在完成时对其进行测试的查询。

清单 8.27 测试 me 根字段的示例查询

```js
{
  me {
    id
    username
  }
}
```

为了支持这个新的根字段，我们需要在 QueryType 下添加它的定义（在 ```api/src/schema/queries.js``` 中）。 由于我们已经在 ```Express``` 侦听器函数（在 ```api/src/server.js``` 中）中获取了 currentUser 记录（对于有效的 authToken 值），我们可以使 currentUser 成为 ```GraphQL``` 上下文对象的一部分，并直接从 resolve 函数返回它 新的我领域。

清单 8.28 api/src/server.js 中的变化

```js
async function main() {
  // ·-·-·
 
  server.use('/', async (req, res) => {
    // ·-·-·
    graphqlHTTP({
      schema,
      context: { loaders, mutators, currentUser },
      graphiql: { headerEditorEnabled: true },
      // ·-·-·
    })(req, res);
  });
 
  // ·-·-·
}
```

清单 8.29 api/src/schema/queries.js 中的变化

```js
// ·-·-·
import User from './types/user';
 
const QueryType = new GraphQLObjectType({
  name: 'Query',
  fields: () => ({
    // ·-·-·
    me: {
      type: User,
      resolve: async (source, args, { currentUser }) => {
        return currentUser;
      },
    },
  }),
});
```

这是一个特殊字段，因为数据库语句不在 ```GraphQL``` 解析器中执行。 这就是为什么我们甚至不需要为它使用 DataLoader 的原因。

继续测试清单 8.27 中的查询（在请求标头中使用有效的 authToken）。 见图 8.7。

![](../images/ch-8/8-7.png)

图 8.7 测试 me 字段

但是，我们设计了 root me 字段来为授权用户提供一种查看其所有任务记录的方法。 接下来我们需要实现User类型下的taskList字段。

为此，我们需要区分在任何用户记录（在任何范围内）上使用的 taskList 字段和在 me 根字段范围内使用的 taskList 字段。

有一些方法可以动态地做到这一点。 其中之一是利用第四个信息参数来找出 taskList 字段的路径。 这可能没问题，但我将使用更简单的方法。

让我们创建两个用户类型！ 我们将保留现有的，并为 me 领域引入一个新的。 新类型获取 taskList 字段。 为了在不复制用户类型字段的情况下实现这一点，我们可以将其字段配置属性设置为一个函数，该函数返回带有或不带有 taskList 字段的字段对象。

这是我想出的。

清单 8.30 api/src/schema/types/user.js 中的新代码

```js
import {
  // ·-·-·
  GraphQLList,
} from 'graphql';
 
import Task from './task';
 
const fieldsWrapper = ({ meScope }) => {
  const userFields = {
    id: { type: new GraphQLNonNull(GraphQLID) },
    username: { type: GraphQLString },
    name: {
      type: GraphQLString,
      resolve: ({ firstName, lastName }) =>
        [firstName, lastName].filter(Boolean).join(' '),
    },
  };
 
  if (meScope) {
    userFields.taskList = {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(Task)),
      ),
      resolve: (source, args, { loaders, currentUser }) => {
        return loaders.tasksForUsers.load(currentUser.id);      ❶
      },
    };
  }
 
  return userFields;
};
const User = new GraphQLObjectType({
  name: 'User',
  fields: () => fieldsWrapper({ meScope: false }),
});
 
export const Me = new GraphQLObjectType({
  name: 'Me',
  fields: () => fieldsWrapper({ meScope: true }),
});
 
export default User;
```

❶ loaders.tasksForUsers 函数还不存在。

这样，该模块有两个出口。 默认是可以在任何地方使用的通用 User 类型，另一种是在 me 字段范围下使用的命名导出（Me）。

以下是如何使用新的 me 类型。

清单 8.31 api/src/schema/queries.js 中的变化

```js
// ·-·-·
import { Me } from './types/user';       ❶
 
const QueryType = new GraphQLObjectType({
  name: 'Query',
  fields: () => ({
    // ·-·-·
     me: {
      type: Me,
      resolve: async (source, args, { currentUser }) => {
        return currentUser;
      },
    },
  }),
});
```

❶ 替换默认的用户导入行

让我们定义 ```loaders.tasksForUsers``` 函数及其批量加载 pgApi 函数。

清单 8.32 api/src/server.js 中的变化

```js
const loaders = {
  // ·-·-·
 
  tasksForUsers: new DataLoader((userIds) =>
    pgApi.tasksForUsers(userIds),
  ),
};
```

pgApi.tasksForUsers 的实现类似于我们之前编写的另一个批量加载函数。 它将使用 ```sqls.tasksForUsers``` 语句并将输入的 ID 数组映射到列表数组中。 我们只会将此函数与当前用户 ID 值一起使用，但在解析器中保持所有数据库获取逻辑相同是一个很好的做法。

清单 8.33 api/src/db/pg-api.js 中的变化

```js
const pgApiWrapper = async () => {
  // ·-·-·
 
  return {
    // ·-·-·
 
    tasksForUsers: async (userIds) => {
      const pgResp = await pgQuery(sqls.tasksForUsers, {
        $1: userIds,
      });
      return userIds.map((userId) =>
        pgResp.rows.filter((row) => userId === row.userId),
      );
    },
 
    // ·-·-·
  };
};
```

你现在可以测试 taskList 字段在 me 字段下是否可用（不要忘记在请求标头中包含有效的 authToken）。 见图 8.8。

![](../images/ch-8/8-8.png)

图 8.8 me 字段下的 taskList 字段

清单 8.34 测试 taskList 的查询

```js
{
  me {
    id
    username
    taskList {
      content
    }
  }
}
```

你还可以使用此查询确保 author 字段下的 taskList 字段不可用。 见图 8.9。

![](../images/ch-8/8-9.png)

图 8.9 taskList 字段在 author 字段范围下不可用。

清单 8.35 测试 author 下的 taskList 的查询

```js
{
  taskMainList {
    content
    author {
      username
      taskList {    ❶
        content
      }
    }
  }
}
```

❶ taskList 字段在 author 字段范围内不应该可用。

> 当前代码
>
> 使用 git checkout 8.4 将你的本地存储库重置为代码中的当前进度。

## 8.5 任务模型的突变

接下来让我们实现 taskCreate 突变字段。 这是它的 SDL 文本的一部分。

清单 8.36 任务突变及其依赖关系的 SDL 文本

```js
input TaskInput {
  content: String!
  tags: [String!]!
  isPrivate: Boolean!
}
 
type TaskPayload {
  errors: [UserError!]!
  task: Task
}
 
type Mutation {
  taskCreate(input: TaskInput!): TaskPayload!
 
  # ·-·-·
}
```

让我们在 ```api/src/schema/types``` 下创建一个新类型来承载 TaskInput 类型。 这是我想出的实现。

清单 8.37 新文件：api/src/schema/types/input-task.js

```js
import {
  GraphQLInputObjectType,
  GraphQLString,
  GraphQLNonNull,
  GraphQLBoolean,
  GraphQLList,
} from 'graphql';
 
const TaskInput = new GraphQLInputObjectType({
  name: 'TaskInput',
  fields: () => ({
    content: { type: new GraphQLNonNull(GraphQLString) },
    tags: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(GraphQLString)),
      ),
    },
    isPrivate: { type: new GraphQLNonNull(GraphQLBoolean) },
  }),
});
 
export default TaskInput;
```

```TaskPayload``` 类型是使用 Task 类型和 UserError 类型（均已定义）的标准 ```GraphQLObjectType```。

清单 8.38 新文件：api/src/schema/types/payload-task.js

```js
import {
  GraphQLObjectType,
  GraphQLNonNull,
  GraphQLList,
} from 'graphql';
 
import Task from './task';
import UserError from './user-error';
 
const TaskPayload = new GraphQLObjectType({
  name: 'TaskPayload',
  fields: () => ({
    errors: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(UserError)),
      ),
    },
    task: { type: Task },
  }),
});
 
export default TaskPayload;
```

我们现在可以导入这两个新类型来创建 taskCreate 突变字段。

清单 8.39 api/src/schema/mutations.js 中的变化

```js
// ·-·-·
import TaskPayload from './types/payload-task';
import TaskInput from './types/input-task';
 
const MutationType = new GraphQLObjectType({
  name: 'Mutation',
  fields: () => ({
    // ·-·-·
 
    taskCreate: {
      type: TaskPayload,
      args: {
        input: { type: new GraphQLNonNull(TaskInput) },
      },
      resolve: async (
        source,
        { input },
        { mutators, currentUser },
      ) => {
        return mutators.taskCreate({ input, currentUser });    ❶
      },
    },
  }),
});
```

❶ mutators.taskCreate 方法还不存在。

对于 ```mutators.taskCreate``` 方法，我们必须首先验证输入值。 例如，让我们确保内容字段至少有 15 个字符。 这类似于我们在 mutators.userCreate 中对密码字段所做的。

如果输入验证成功，我们可以插入新的任务记录并将其作为突变负载的一部分返回。 我为这个突变准备的 SQL 语句是 ```sqls.taskInsert```。

清单 8.40 api/src/db/pg-api.js 中的变化

```js
const pgApiWrapper = async () => {
  // ·-·-·
 
  return {
    // ·-·-·
    mutators: {
      // ·-·-·
      taskCreate: async ({ input, currentUser }) => {
        const payload = { errors: [] };
        if (input.content.length < 15) {
          payload.errors.push({
            message: 'Text is too short',
          });
        }
        if (payload.errors.length === 0) {
          const pgResp = await pgQuery(sqls.taskInsert, {
            $1: currentUser.id,
            $2: input.content,
            $3: input.tags.join(','),     ❶
            $4: input.isPrivate,
          });
 
          if (pgResp.rows[0]) {
            payload.task = pgResp.rows[0];
          }
        }
 
        return payload;
      },
    },
  };
};
```

❶ 请记住，标签在数据库中存储为逗号分隔值，但 API 使用者将它们作为字符串数组发送。 这就是为什么我们需要在这里进行连接调用。

这是一个请求，你可以在 ```GraphiQL``` 中使用它来测试 taskCreate 突变。

清单 8.41 请求测试 taskCreate

```js
mutation taskCreate {
  taskCreate (
    input: {
      content: "Use INSERT/SELECT together in PostgreSQL",
      tags: ["sql", "postgresql"]
      isPrivate: false,
   }
  ) {
    errors {
      message
    }
    task {
      id
      content
      tags
      author {
        id
      }
      createdAt
    }
  }
}
```

在请求标头中使用和不使用有效的 authToken 值进行测试。

> 当前代码
>
> 使用 git checkout 8.5 将你的本地存储库重置为代码中的当前进度。

> **挑战**
>
> 如果 API 消费者拥有任务记录，则为他们提供更新任务记录的方法。

## 8.6 方法模型的突变

现在让我们实现两个突变，以将方法添加到任务 (```approachCreate```) 并对现有方法进行投票 (```approachVote```)。

### 8.6.1 方法创建突变

这是我们需要关注的 SDL 部分，以实现 ```approachCreate``` 突变。

清单 8.42 approachCreate 及其依赖项的 SDL

```js
input ApproachDetailInput {
  content: String!
  category: ApproachDetailCategory!
}
 
input ApproachInput {
  content: String!
  detailList: [ApproachDetailInput!]!
}
 
type ApproachPayload {
  errors: [UserError!]!
  approach: Approach
}
 
type Mutation {
  approachCreate(
    taskId: ID!
    input: ApproachInput!
  ): ApproachPayload!
 
  # ·-·-·
}
```

这次让我们从 mutation 字段开始，它位于 ```api/src/schema/mutations.js``` 中。 让我们计划有一个 ```mutators.approachCreate``` 函数来调用数据库语句。

因为一条 Approach 记录可能有额外的 Detail 元素，所以这个变化必须在 PostgreSQL 中插入一条记录，然后在 MongoDB 中插入一个文档。 MongoDB 操作依赖于 PostgreSQL 操作。 实现它的最简单方法是使用依赖注入并让主要的 ```mutators.approachCreate``` 函数按顺序在两个数据库中完成工作。 一种方法是将上下文级别的增变器对象作为参数传递给主增变器函数。

清单 8.43 api/src/schema/mutations.js 中的变化

```js
import {
  // ·-·-·
  GraphQLID,
} from 'graphql';
// ·-·-·
import ApproachPayload from './types/payload-approach';  ❶
import ApproachInput from './types/input-approach';      ❶
 
const MutationType = new GraphQLObjectType({
  name: 'Mutation',
  fields: () => ({
    // ·-·-·
 
    approachCreate: {
      type: ApproachPayload,
      args: {
        taskId: { type: new GraphQLNonNull(GraphQLID) },
        input: { type: new GraphQLNonNull(ApproachInput) },
      },
      resolve: async (
        source,
        { taskId, input },
        { mutators, currentUser },
      ) => {
        return mutators.approachCreate({                 ❷
          taskId,
          input,
          currentUser,
          mutators,                                      ❸
        });
      },
    },
  }),
});
```

❶ 我们还没有实现这些类型。
❷ 主要修改器（尚未实现）
❸ 注意这里传递的是 mutators 对象。

这样，```mutators.approachCreate``` 函数可以从 PostgreSQL 插入开始，然后调用不同的 mutator 函数在 MongoDB 中执行插入。 或者，我们可以在 resolve 函数中用两个不同的函数调用两个数据库操作，但我认为让一个 mutator 函数负责完整的 Approach 插入操作更清晰。

提示 我们可以依赖于 mutators 是 ```approachCreate``` 的调用者这一事实，而不是将 mutators 作为参数传递，使 ```approachCreate``` 成为一个常规（非箭头）函数，然后使用 this 关键字访问其中的 mutators。 我认为论证方法更具可读性。

让我们创建此突变使用的有效负载和输入类型。 我们有 ```ApproachPayload```，它是 ```GraphQLObjectType``` 的一个简单实例。

清单 8.44 新文件：api/src/schema/types/payload-approach.js

```js
import {
  GraphQLList,
  GraphQLNonNull,
  GraphQLObjectType,
} from 'graphql';
 
import Approach from './approach';
import UserError from './user-error';
 
const ApproachPayload = new GraphQLObjectType({
  name: 'ApproachPayload',
  fields: () => ({
    errors: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(UserError)),
      ),
    },
    approach: { type: Approach },
  }),
});
 
export default ApproachPayload;
```

```ApproachDetailInput``` 和 ```ApproachInput``` 类型都是 ```GraphQLInputObjectType``` 的实例。

清单 8.45 新文件：api/src/schema/types/input-approach-detail.js

```js
import {
  GraphQLInputObjectType,
  GraphQLString,
  GraphQLNonNull,
} from 'graphql';
 
import ApproachDetailCategory from './approach-detail-category'; 
 
const ApproachDetailInput = new GraphQLInputObjectType({
  name: 'ApproachDetailInput',
  fields: () => ({
    content: { type: new GraphQLNonNull(GraphQLString) },
    category: {
      type: new GraphQLNonNull(ApproachDetailCategory),
    },
  }),
});
 
export default ApproachDetailInput;
```

清单 8.46 新文件：api/src/schema/types/input-approach.js

```js
import {
  GraphQLInputObjectType,
  GraphQLString,
  GraphQLNonNull,
  GraphQLList,
} from 'graphql';
 
import ApproachDetailInput from './input-approach-detail';
 
const ApproachInput = new GraphQLInputObjectType({
  name: 'ApproachInput',
  fields: () => ({
    content: { type: new GraphQLNonNull(GraphQLString) },
    detailList: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(ApproachDetailInput)),
      ),
    },
  }),
});
 
export default ApproachInput;
```

要实现 ```mutators.approachCreate```，我们可以使用 ```sqls.approachInsert``` 语句将主要的 Approach 记录插入到 PostgreSQL 中。 如果成功，我们将新创建的 Approach 记录的 ID 传递给 MongoDB mutators 方法。 此外，我们需要增加 ```azdev.tasks``` 表中的 ```approach_count``` 列。 我准备了语句 ```sqls.approachCountIncrement``` 来执行此操作。

清单 8.47 api/src/db/pg-api.js 中的变化

```js
const pgApiWrapper = async () => {
  // ·-·-·
 
  return {
    // ·-·-·
 
    mutators: {
      // ·-·-·
 
      approachCreate: async ({
        taskId,
        input,
        currentUser,
        mutators,
      }) => {
        const payload = { errors: [] };
          if (payload.errors.length === 0) {
            const pgResp = await pgQuery(sqls.approachInsert, {   ❶
            $1: currentUser.id,
            $2: input.content,
            $3: taskId,
          });
          if (pgResp.rows[0]) {
            payload.approach = pgResp.rows[0];
            await pgQuery(sqls.approachCountIncrement, {         ❷
              $1: taskId,
            });
            await mutators.approachDetailCreate(                 ❸
              payload.approach.id,
              input.detailList,
            );
          }
        }
 
        return payload;
      },
    },
  };
};
```

❶ 调用 PostgreSQL 操作创建 Approach 记录
❷ 创建了 Approach 记录。 增加任务的 approachCount。
❸ 继续在 MongoDB 中添加其详细信息。

还记得当我们在 approaches 字段下实现 detailList 字段时，我们必须将列表从对象（存储在 MongoDB 中）转换为数组（为 detailList 定义）吗？ 我们需要对 approachDetailCreate 方法进行精确的逆转换。 我们需要转换这种格式（正如我们为 ```ApproachDetailInput``` 类型设计的那样）：

```js
[
  {
    content: explanationsValue1,
    category: "EXPLANATION"
  },
  {
    content: notesValue1,
    category: "NOTE"
  },
  {
    content: warningsValue1,
    category: "WARNING"
  },
  ·-·-·
]
```

这是我们将其转换成的格式，这是 ```approachDetails MongoDB``` 集合所期望的格式：

```js
{
  explanations: [explanationsValue1, ·-·-·],
  notes: [notesValue1, ·-·-·],
  warnings: [warningsValue1, ·-·-·],
}
```

一个简单的循环就可以解决问题。 以下是我针对此转换和插入 MongoDB 记录的想法。

清单 8.48 api/src/db/mongo-api.js 中的变化

```js
const mongoApiWrapper = async () => {
  // ·-·-·
 
  return {
    // ·-·-·
 
    mutators: {
      approachDetailCreate: async (approachId, detailsInput) => {
        const details = {};
        detailsInput.forEach(({ content, category }) => {
          details[category] = details[category] || [];
          details[category].push(content);
        });
        return mdb.collection('approachDetails').insertOne({
          pgId: approachId,
          ...details,
        });
      },
    },
  };
};
```

然而，尽管这是我们必须做的事情的正确方向，但它不会奏效。 这段代码有问题。 你能发现吗？

清单 8.48 中的 forEach 循环被优化为使用类别 ```VALUES``` 作为新对象的键。 但是，存储在数据库中的值是小写复数（即 notes），而暴露给消费者（并在输入中使用）的值是大写单数（即 NOTE）。 ```GraphQL``` 的 ```ENUM``` 类型没有在代码中进行这种转换，而是提供了一种方法来更改项目的值以匹配数据库中存储的内容，并且仍然向 API 消费者公开不同的值。 以下是如何做到这一点。

清单 8.49 api/src/schema/types/approach-detail-category.js 中的变化

```js
const ApproachDetailCategory = new GraphQLEnumType({
  name: 'ApproachDetailCategory',
  values: {
    NOTE: { value: 'notes' },
    EXPLANATION: { value: 'explanations' },
    WARNING: { value: 'warnings' },
  },
});
```

这样，消费者看到的是大写版本，但 ```GraphQL``` 会在与数据库通信时将其转换为小写版本。 但是，我们现在需要更改我们所做的第一个转换以处理此 ENUM 类型更改。

清单 8.50 api/src/db/mongo-api.js 中的变化

```js
const mongoApiWrapper = async () => {
  // ·-·-·
 
  return {
    detailLists: async (approachIds) => {
      // ·-·-·
      return approachIds.map((approachId) => {
        // ·-·-·
        if (explanations) {
          approachDetails.push(
            ...explanations.map((explanationText) => ({
              content: explanationText,
              category: 'explanations',
            }))
          );
        }
        if (notes) {
          approachDetails.push(
            ...notes.map((noteText) => ({
              content: noteText,
              category: 'notes',
            }))
          );
        }
        if (warnings) {
          approachDetails.push(
            ...warnings.map((warningText) => ({
              content: warningText,
              category: 'warnings',
            }))
          );
        }
        return approachDetails;
      });
    },
 
    // ·-·-·
  };
};
```

就这样！ 你可以使用以下请求测试 ```approachCreate``` 突变。

清单 8.51 请求测试 approachCreate

```js
mutation approachCreate {
  approachCreate(
    taskId: 42 # Get this value from a taskCreate mutation call
    input: {
      content: "INSERT INTO tableName ·-·-·] ) ] SELECT-STATEMENT",
      detailList: [
        {
          content: "You can still use a RETURNING clause after that",
          category: NOTE,
        },
        {
          content: "The INSERT statement only works if the SELECT statement 
          ➥ does",
          category: EXPLANATION,
        },
      ],
    }
  ) {
    errors {
      message
    }
    approach {
      id
      content
      voteCount
      author {
        username
      }
      detailList {
        content
        category
      }
    }
  }
}
```

提示当对相关实体使用不同的数据源时，错误处理变得更具挑战性。 例如，想一想如果MongoDB在创建Approach时出现错误，需要做什么。 PostgreSQL 中的 Approach 记录应该怎么办？

处理跨数据库相关操作的一种方法是使用数据库事务，它允许我们将多个操作分组并将它们视为一个工作单元，可以完全发生或根本不发生。 在 PostgreSQL 中，事务是通过用 BEGIN 和 COMMIT 命令包围事务的 SQL 命令来建立的； 并且可以使用 ROLLBACK 命令取消事务。 将它与 JavaScript 中的 try/catch 语句相结合，提供了一种方法来确保与跨数据库相关的工作要么完成，要么应该作为错误报告给消费者。

> 当前代码
>
> 使用 git checkout 8.6 将你的本地存储库重置为代码中的当前进度。

> **挑战**
>
> 为 API 消费者提供一种向现有 Approach 记录添加更多详细信息的方法。

提示 我们可以使用 PostgreSQL 触发器的强大功能在数据库中执行此操作，而不是在插入 Approach 对象后使用单独的 SQL 语句来增加 approach_count 列。

### 8.6.2 approachVote 突变

我们计划为 AZdev API 消费者提供一种对 Approach 记录进行投票的方式。 他们可以对任何方法投赞成票或反对票。

这是我们需要关注 approachVote 突变的 SDL 文本部分。

清单 8.52 用于 approachVote 及其依赖项的 SDL

```js
input ApproachVoteInput {
  """true for up-vote and false for down-vote"""
  up: Boolean!
}
 
type Mutation {
  approachVote(
    approachId: ID!
    input: ApproachVoteInput!
  ): ApproachPayload!
 
  # ·-·-·
}
```

在这一点上，如果你不尝试自己实施此变更，我会感到非常失望。 为了让你没有不尝试的借口，我准备了你可以使用的 ```sqls.approachVote``` 语句。

清单 8.53 approachVote SQL 语句在 api/src/db/sqls.js

```js
// $1: approachId
// $2: voteIncrement
approachVote: `
  UPDATE azdev.approaches
  SET vote_count = vote_count + $2
  WHERE id = $1
  RETURNING id, content, ·-·-·;
`,
```

```sqls.approachVote``` 语句需要按以下顺序输入：

#### 用户投票的方法的 ID

```voteIncrement``` 值，应为 1 或 -1，具体取决于投票类型（1 表示赞成，-1 表示反对）
这是一个请求，你可以在 ```GraphiQL``` 中使用它来测试你的实现。

清单 8.54 请求测试 approachVote

```js
mutation approachVote {
  approachVote(
    approachId: 42 # Get this value from approachCreate
    input: { up: false }
  ) {
    errors {
      message
    }
    approach {
      content
      voteCount
    }
  }
}
```

以下是我为实现 ```approachVote``` 突变所做的更改。

清单 8.55 新文件：api/src/schema/types/input-approach-vote.js

```js
import {
  GraphQLInputObjectType,
  GraphQLBoolean,
  GraphQLNonNull,
} from 'graphql';
 
const ApproachVoteInputType = new GraphQLInputObjectType({
  name: 'ApproachVoteInput',
  description: "true for up-vote and false for down-vote",
  fields: () => ({
    up: { type: new GraphQLNonNull(GraphQLBoolean) },
  }),
});
 
export default ApproachVoteInputType;
```

清单 8.56 api/src/schema/mutations.js 中的变化

```js
// ·-·-·
import ApproachVoteInput from './types/input-approach-vote';
 
const MutationType = new GraphQLObjectType({
  name: 'Mutation',
  fields: () => ({
    // ·-·-·
    approachVote: {
      type: ApproachPayload,
      args: {
        approachId: { type: new GraphQLNonNull(GraphQLID) },
        input: { type: new GraphQLNonNull(ApproachVoteInput) },
      },
      resolve: async (
        source,
        { approachId, input },
        { mutators },
      ) => {
        return mutators.approachVote({ approachId, input });
      },
    },
  }),
});
```

清单 8.57 api/src/db/pg-api.js 中的变化； 新的突变函数

```js
const pgApiWrapper = async () => {
  // ·-·-·
 
  return {
    // ·-·-·
    mutators: {
      // ·-·-·
      approachVote: async ({ approachId, input }) => {
        const payload = { errors: [] };
        const pgResp = await pgQuery(sqls.approachVote, {
          $1: approachId,
          $2: input.up ? 1 : -1,
        });
 
        if (pgResp.rows[0]) {
          payload.approach = pgResp.rows[0];
        }
 
        return payload;
      },
    },
  };
};
```

继续测试清单 8.54 中的变异请求（它应该否决一个方法对象）。

注意我没有检查此突变是否存在有效的用户会话。 这意味着来宾用户也可以投票。 我省略了那部分，所以我们有一个示例突变，我们可以在没有请求标头的情况下进行测试。

> 当前代码
>
> 使用 git checkout 8.7 将你的本地存储库重置为代码中的当前进度。

## 8.7 userDelete 突变

我们为 AZdev API 计划的最后一个变化是为用户提供一种删除其帐户的方法。 这是我们准备的 SDL 部分。

清单 8.58 用于删除用户的 SDL 文本

```js
type UserDeletePayload {
  errors: [UserError!]!
  deletedUserId: ID
}
 
type Mutation {
  userDelete: UserDeletePayload!
 
  # ·-·-·
}
```

首先尝试自己实现它。 我已经准备好 ```sqls.userDelete``` 语句。 ```UserDeletePayload``` 是 ```GraphQLObjectType``` 的一个简单实例。

清单 8.59 新文件：api/src/schema/types/payload-user-delete.js

```js
import {
  GraphQLList,
  GraphQLNonNull,
  GraphQLObjectType,
  GraphQLID,
} from 'graphql';
 
import UserError from './user-error';
 
const UserDeletePayload = new GraphQLObjectType({
  name: 'UserDeletePayload',
  fields: () => ({
    errors: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(UserError)),
      ),
    },
    deletedUserId: { type: GraphQLID },
  }),
});
 
export default UserDeletePayload;
```

接下来让我们实现 mutator 函数。 它将在其参数中接收 currentUser 对象，调用 ```sqls.userDelete``` 语句，然后将 ```deletedUserId``` 值作为其有效负载的一部分返回。

清单 8.60 api/src/db/pg-api.js 中的变化

```js
const pgApiWrapper = async () => {
  // ·-·-·
 
  return {
    // ·-·-·
 
    mutators: {
      // ·-·-·
 
      userDelete: async ({ currentUser }) => {
        const payload = { errors: [] };
        try {
          await pgQuery(sqls.userDelete, {
            $1: currentUser.id,
          });
          payload.deletedUserId = currentUser.id;
        } catch (err) {
          payload.errors.push({
            message: 'We were not able to delete this account',
          });
        }
 
        return payload;
      },
    },
  };
};
```

最后，我们在新变异字段的解析函数中使用这个变异函数。

清单 8.61 api/src/schema/mutations.js 中的变化

```js
// ·-·-·
import UserDeletePayload from './types/payload-user-delete';
 
const MutationType = new GraphQLObjectType({
  name: 'Mutation',
  fields: () => ({
    // ·-·-·
 
    userDelete: {
      type: UserDeletePayload,
      resolve: async (source, args, { mutators, currentUser }) => {
        return mutators.userDelete({ currentUser });
      },
    },
  }),
});
```

而已。 要测试这个突变，使用清单 8.13 中的 userCreate 突变示例创建一个新的用户帐户，在请求标头编辑器中使用该帐户的 authToken 值，并发送以下突变请求。

清单 8.62 测试 userDelete 的变更请求示例

```js
mutation userDelete {
  userDelete {
    errors {
      message
    }
    deletedUserId
  }
}
```

请注意，只有当用户不拥有任何任务或方法记录时，此更改才会起作用。 否则，这些关系中的外键约束会阻塞删除操作。 作为供你参考的示例，我在此操作中使用了 try/catch 语句来捕获任何数据库错误并使用一般用户错误消息来暴露问题。 也测试一下。

提示如果即使用户拥有数据库中的其他记录，你也想启用删除用户记录，PostgreSQL 支持外键约束的 ON DELETE 选项，自动删除（或更新）要删除的记录引用的所有记录。 这比执行许多 DELETE SQL 语句要好得多。

> 当前代码
>
> 使用 git checkout 8.8 将你的本地存储库重置为代码中的当前进度。

> **挑战**
>
> 为 API 消费者提供一种删除自己的任务记录的方法。

这样，这个 GraphQL 模式就可以很好地执行，提供一个 API 来构建一个可用的 UI 产品，而这正是我们将在本书的第 3 部分中做的事情。

注意 为了使到目前为止的所有实现都简单、简短和易于遵循，我跳过了许多我想做的更改。 例如，所有这些突变都需要更多的输入验证。 此外，代码可以使用许多优化和抽象，在某些情况下，还可以使用急需的保护措施。 例如，approachVote 突变允许任何人根据自己的意愿进行多次投票，甚至可以根据私人需要进行投票。 那不应该发生。 查看 ```az.dev/contribute``` 上的代码存储库，了解本书中未提及的更改历史。 请随时在 ```jscomplete.com/help``` 上的 jsComplete 帮助频道中询问有关最终代码的任何问题。

#### 订阅操作

```GraphQL.js``` 对创建订阅有一些支持，但它仍在不断发展。 此外，要使用订阅，必须使用支持网络套接字的传输服务器。 到目前为止我们使用的简单 express.js 服务器设置不支持它。 ```GraphiQL``` 也不支持测试订阅（更准确地说，你可以使用 ```GraphiQL``` 进行一些测试，但设置有点复杂）。
好消息是无需复杂设置即可创建、测试和使用订阅的工具。 ```Apollo``` 服务器/客户端是最受欢迎的。 还有 ```graphql-yoga``` 包，它包含一些很棒的抽象来帮助实现订阅。
虽然走复杂的路线将是一个很好的教育示例，但这里的实际解决方案是使用一种经过充分测试的支持订阅的工具。 由于本书的最后一章重点介绍了 Apollo 生态系统，我们将在那里实现和使用订阅操作。

## 概括

- 要承载突变，```GraphQL``` 模式必须定义根突变类型。
- 要为突变组织数据库操作，你可以将它们分组到一个对象上，该对象作为解析器的全局上下文的一部分公开。
- 用户友好的错误消息可以而且应该作为任何突变响应的一部分包含在内。
- PostgreSQL RETURNING 子句可用于在单个 SQL 语句中执行 WRITE 操作，然后执行 READ 操作。 INSERT/SELECT 组合使我们能够使 WRITE 操作依赖于单个 SQL 语句中的 READ 操作。
- 散列令牌值可用作突变操作和查询操作的临时密码，这些操作对于经过身份验证的用户应该有不同的行为。
- 一些变异操作相互依赖。 在这些情况下可以使用依赖注入。